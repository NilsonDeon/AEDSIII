// Package
package casamentoPadroes;

// Bibliotecas
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;

public class KMP {

    private byte[] padraoBytes;
    private String padraoString;
    private int prefixoBasico[];

    // Arquivo de registro
    private static final String registroDB = "./src/resources/Registro.db";

    /**
     * Construtor padrao da classe KMP.
     */
    public KMP() {

        padraoBytes = new byte[0];
        padraoString = "";
        prefixoBasico = new int[0];
    }

    public int procurarPadrao (String padraoProcurado) {

        // Settar padrao procurado
        padraoString = padraoProcurado;
        padraoBytes = padraoString.getBytes();

        // Montar tabela hash de prefixo basico;
        montarPrefixoBasico();

        // Contar comparacoes
        int numComparacoes = 0;

        // Abrir arquivo para busca
        RandomAccessFile dbFile = null;

        try {
            dbFile = new RandomAccessFile(registroDB, "r");
            dbFile.seek(0);

            // Obter tamanho do arquivo
            File arqRegistro = new File(registroDB);
            long tamArquivo = arqRegistro.length();

            // Calcular numero de ocorrencias possiveis
            long ultimaPos = tamArquivo - (padraoBytes.length-1);
            long posAtual = dbFile.getFilePointer();

            // Percorrer ate' ultima posicao possivel
            while(posAtual != ultimaPos) {
                
                int deslocamento = 0;
                boolean find = true;
                for(int i = 0; i < padraoBytes.length && find; i++){

                    // Ler byte para casar
                    byte byteAtual = dbFile.readByte();

                    // Contabilizar comparacoes
                    numComparacoes++;

                    // Se nao houve correspondencia, analisar deslocamento possivel
                    if (byteAtual != padraoBytes[i]) {
                        deslocamento = i - prefixoBasico[i];
                        find = false;
                    }
                }

                // Testar se encontrou
                if (find) {
                    dbFile.seek(posAtual+1);
                    posAtual = dbFile.getFilePointer();
                    System.out.println("\nfind\n");
                    
                } else {
                    long newPos = posAtual + deslocamento;
                    dbFile.seek(newPos);
                    posAtual = dbFile.getFilePointer();
                }
            }

        } catch (FileNotFoundException e) {

        } catch (IOException e) {

        }
        

        return numComparacoes;

    }

    private void montarPrefixoBasico() {

        // Settar array
        prefixoBasico = new int[padraoBytes.length];

        // Duas primeiras posicoes, por definicao, -1 e 0
        prefixoBasico[0] = -1;
        if (padraoBytes.length >1) prefixoBasico[1] = 0;

        // Adicionar valor para outras posicoes
        for(int i = 2; i < padraoBytes.length; i++) {

            byte byteAnterior = padraoBytes[i-1];

            // Obter proxima posicao a ser analisada
            int pos = i-2;

            // Settar default para posicao atual
            prefixoBasico[i] = prefixoBasico[i-1] + 1;

            // Repetir ate' nao ser necessario mais a busca
            boolean stop = false;
            while (!stop) {

                // Tentar encontrar padrao repetido
                while(pos >= 0 && byteAnterior != padraoBytes[pos]) {
                    prefixoBasico[i] = pos;
                    pos--;
                }

                // Testar se encontrou de fato
                if (pos > 0) {
                    int newPos = pos;
                    int dif = i-1;;

                    // Verificar se o padrao se mantem aparecendo
                    while (newPos > 0 && padraoBytes[newPos--] == padraoBytes[dif--]);

                    // Testar se ultimo prefixo a se analisar e' o prefixo do padrao
                    if (newPos == 0 && padraoBytes[newPos] == padraoBytes[dif]) {
                        stop = true;
                    
                    // Se nao for, resetar busca
                    } else {
                        prefixoBasico[i] = 0;
                    }

                // Marcar como fim se tiver chegado 'a ultima comparacao
                } else {
                    stop = true;
                }

                pos--;
            }

        }

    }


}